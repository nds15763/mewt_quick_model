<!DOCTYPE html>
<!--
  Debug Page - Camera Access Diagnostic Tool
  
  Purpose: Diagnose why WebView camera access is failing
  URL: https://mewt.vercel.app/debug
  
  This page tests camera access step-by-step with detailed logging
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Camera Debug</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background-color: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }

    #video {
      width: 100%;
      max-width: 640px;
      height: auto;
      border: 2px solid #0f0;
      margin-bottom: 20px;
    }

    #logs {
      background-color: #111;
      padding: 10px;
      border: 1px solid #0f0;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .log-entry {
      margin: 5px 0;
      padding: 5px;
      border-left: 3px solid #0f0;
      padding-left: 10px;
    }

    .log-error {
      color: #f00;
      border-left-color: #f00;
    }

    .log-success {
      color: #0f0;
      border-left-color: #0f0;
    }

    .log-info {
      color: #ff0;
      border-left-color: #ff0;
    }

    h1 {
      color: #0f0;
      margin-bottom: 20px;
    }

    button {
      background-color: #0f0;
      color: #000;
      border: none;
      padding: 10px 20px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      margin: 5px;
    }

    button:hover {
      background-color: #0c0;
    }
  </style>
</head>
<body>
  <h1>üîç Camera Access Debug Tool</h1>
  
  <div>
    <button onclick="testCameraAccess()">Test Camera Access</button>
    <button onclick="clearLogs()">Clear Logs</button>
  </div>
  
  <video id="video" autoplay playsinline></video>
  <div id="logs"></div>

  <script>
    const video = document.getElementById('video');
    const logsDiv = document.getElementById('logs');
    let logCount = 0;

    // Logging function
    function log(message, type = 'info', data = null) {
      logCount++;
      const timestamp = new Date().toISOString().substr(11, 12);
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry log-${type}`;
      
      let logText = `[${timestamp}] ${message}`;
      if (data) {
        logText += '\n' + JSON.stringify(data, null, 2);
      }
      
      logEntry.textContent = logText;
      logsDiv.appendChild(logEntry);
      logsDiv.scrollTop = logsDiv.scrollHeight;
      
      // Also log to console
      console.log(`[Debug] ${message}`, data || '');
      
      // Send to RN if available
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'debug_log',
          message: message,
          data: data,
          timestamp: Date.now(),
          level: type
        }));
      }
    }

    function clearLogs() {
      logsDiv.innerHTML = '';
      logCount = 0;
      log('Logs cleared', 'info');
    }

    // Main camera test function
    async function testCameraAccess() {
      log('üöÄ Starting camera access test...', 'info');
      
      // Step 1: Check if getUserMedia exists
      log('Step 1: Checking if getUserMedia API exists...', 'info');
      if (!navigator.mediaDevices) {
        log('‚ùå navigator.mediaDevices is undefined!', 'error');
        return;
      }
      log('‚úÖ navigator.mediaDevices exists', 'success');
      
      if (!navigator.mediaDevices.getUserMedia) {
        log('‚ùå getUserMedia function is undefined!', 'error');
        return;
      }
      log('‚úÖ getUserMedia function exists', 'success');
      
      // Step 2: Check permissions API
      log('Step 2: Checking permissions API...', 'info');
      if (navigator.permissions) {
        try {
          const cameraPermission = await navigator.permissions.query({ name: 'camera' });
          log('Camera permission state:', 'info', { state: cameraPermission.state });
          
          const micPermission = await navigator.permissions.query({ name: 'microphone' });
          log('Microphone permission state:', 'info', { state: micPermission.state });
        } catch (e) {
          log('Permissions API query failed (this is OK on some platforms)', 'info', { error: e.message });
        }
      } else {
        log('Permissions API not available (this is OK)', 'info');
      }
      
      // Step 3: List available devices
      log('Step 3: Enumerating media devices...', 'info');
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        const audioDevices = devices.filter(d => d.kind === 'audioinput');
        
        log('Video devices found:', 'success', { 
          count: videoDevices.length,
          devices: videoDevices.map(d => ({ label: d.label, deviceId: d.deviceId.substr(0, 20) + '...' }))
        });
        log('Audio devices found:', 'success', { 
          count: audioDevices.length,
          devices: audioDevices.map(d => ({ label: d.label, deviceId: d.deviceId.substr(0, 20) + '...' }))
        });
      } catch (e) {
        log('‚ùå Failed to enumerate devices', 'error', { error: e.message, name: e.name });
      }
      
      // Step 4: Request video + audio
      log('Step 4: Requesting video + audio stream...', 'info');
      const constraints = {
        video: { 
          facingMode: { ideal: "environment" },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: true
      };
      log('Constraints:', 'info', constraints);
      
      try {
        log('Calling getUserMedia...', 'info');
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        
        log('‚úÖ getUserMedia SUCCESS!', 'success', {
          videoTracks: stream.getVideoTracks().length,
          audioTracks: stream.getAudioTracks().length
        });
        
        // Step 5: Display the stream
        log('Step 5: Attaching stream to video element...', 'info');
        video.srcObject = stream;
        
        // Wait for video to be ready
        video.onloadedmetadata = () => {
          log('‚úÖ Video metadata loaded', 'success', {
            videoWidth: video.videoWidth,
            videoHeight: video.videoHeight,
            duration: video.duration
          });
        };
        
        video.onplay = () => {
          log('‚úÖ Video playing!', 'success', {
            currentTime: video.currentTime,
            paused: video.paused,
            ended: video.ended
          });
        };
        
        // Log track details
        stream.getVideoTracks().forEach((track, i) => {
          log(`Video Track ${i}:`, 'success', {
            label: track.label,
            enabled: track.enabled,
            muted: track.muted,
            readyState: track.readyState,
            settings: track.getSettings()
          });
        });
        
        stream.getAudioTracks().forEach((track, i) => {
          log(`Audio Track ${i}:`, 'success', {
            label: track.label,
            enabled: track.enabled,
            muted: track.muted,
            readyState: track.readyState
          });
        });
        
      } catch (error) {
        log('‚ùå getUserMedia FAILED', 'error', {
          name: error.name,
          message: error.message,
          constraint: error.constraint,
          stack: error.stack
        });
        
        // Try fallback: video only
        log('Attempting fallback: video only...', 'info');
        try {
          const fallbackConstraints = { video: true };
          log('Fallback constraints:', 'info', fallbackConstraints);
          
          const stream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
          log('‚úÖ Fallback SUCCESS (video only)', 'success', {
            videoTracks: stream.getVideoTracks().length,
            audioTracks: stream.getAudioTracks().length
          });
          
          video.srcObject = stream;
        } catch (fallbackError) {
          log('‚ùå Fallback also FAILED', 'error', {
            name: fallbackError.name,
            message: fallbackError.message,
            constraint: fallbackError.constraint
          });
        }
      }
    }

    // Auto-run on load
    window.addEventListener('DOMContentLoaded', () => {
      log('üì± Debug page loaded', 'success', {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        onLine: navigator.onLine,
        cookieEnabled: navigator.cookieEnabled
      });
      
      log('üîç WebView detection:', 'info', {
        hasReactNativeWebView: !!window.ReactNativeWebView,
        hasAndroid: !!window.Android
      });
      
      // Auto-start test after 1 second
      setTimeout(() => {
        log('Auto-starting camera test in 1 second...', 'info');
        setTimeout(testCameraAccess, 1000);
      }, 100);
    });

    // Global error handler
    window.addEventListener('error', (e) => {
      log('‚ùå Global error caught', 'error', {
        message: e.message,
        filename: e.filename,
        lineno: e.lineno,
        colno: e.colno
      });
    });

    // Unhandled promise rejection handler
    window.addEventListener('unhandledrejection', (e) => {
      log('‚ùå Unhandled promise rejection', 'error', {
        reason: e.reason,
        promise: e.promise
      });
    });
  </script>
</body>
</html>
